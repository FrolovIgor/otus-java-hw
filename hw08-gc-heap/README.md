# Результаты определения нужного размера хипа

В таблице ниже приведены результаты измерения времени работы приложения в зависимости от различного размера JavaHeap.


|           | 1  |2|3|4|5|AVG
|-----------|----|-|-|-|-|--
| **256M**  |7801|8170|7978|8291|7777|8003
| **2G**    |3747|3733|3657|3672|3759|3713
| **1G**    |3912|3943|3708|3975|3810|3870
| **512M**  |4865|4740|4675|4836|4840|4791
| **768M**  |4195|4377|4324|4333|4421|4330
| **1536M** |3768|3709|3777|3791|3719|3752
| **1792M** |3315|3451|3327|3366|3426|3377
| **1700M** |3218|3232|3350|3267|3277|3268
| **1720M** |3174|3249|3233|3349|3312|3263

В таблице приведены по 5 измерений для каждого размера heap, и в последней колонке посчитано среднее. 
Из неё мы видим, что при маленьких значениях, время выполнения осталяет желать лучшего) 
видно что при значениях около 1700M время выполнения минимальное. 

Для оптимизации алгоритма я убрал final с поля в классе Data, добавил для него setter. 
Это позволяет не создавать 100млн объектов, а просто делать set. 

|           | 1  |2|3|4|5|AVG
|-----------|----|-|-|-|-|--
| **110M**  |3237|3372|3459|3382|3422|3374
| **120M**  |3195|3351|3319|3401|3350|3323
| **128M**  |3226|3215|3223|3262|3179|3221
| **140M**  |3200|3461|3428|3308|3379|3355
| **256M**  |3428|3360|3389|3423|3409|3401
| **1G**    |3714|3695|3652|3747|3730|3707
| **1700M** |3767|3729|3739|3726|3738|3740
| **2G**    |3957|3716|3817|3783|3692|3793

в итоге видим что наша прошграмма отрабатывает с минимальным размером heap, даже с 128M. Уменьшение heap несколько увеличивает время выполнения

До оптипизации оптимальным размером Heap считаю 1700Mb, после оптимизации - 128Mb.